"use strict";(self.webpackChunkmontrecode_docs=self.webpackChunkmontrecode_docs||[]).push([[40],{3071:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"coda","title":"Coda","description":"La coda \xe8 una struttura dati dinamica e lineare (come la sequenza), la quale impone una regola particolare nella gestione dell\'inserimento e rimozione degli elementi: l\'elemento da rimuovere \xe8 sempre quello che ha percorso il maggior tempo all\'interno dell\'insieme.","source":"@site/docs/06-coda.md","sourceDirName":".","slug":"/coda","permalink":"/montrecode/coda","draft":false,"unlisted":false,"editUrl":"https://github.com/DavideDaCol/montrecode/tree/main/docs/06-coda.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Pila","permalink":"/montrecode/pila"}}');var o=t(4848),a=t(8453);const r={},s="Coda",l={},c=[{value:"Operazioni",id:"operazioni",level:2},{value:"Possibile implementazione",id:"possibile-implementazione",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"coda",children:"Coda"})}),"\n",(0,o.jsxs)(n.p,{children:["La coda \xe8 una struttura dati dinamica e lineare (come la ",(0,o.jsx)(n.a,{href:"/montrecode/Strutture%20Dati%20Base/sequenza",children:"sequenza"}),"), la quale impone una regola particolare nella gestione dell'inserimento e rimozione degli elementi: l'elemento da rimuovere \xe8 sempre quello che ha percorso il maggior tempo all'interno dell'insieme."]}),"\n",(0,o.jsxs)(n.p,{children:['In questi casi si parla di "Politica FIFO (First In First Out)", siccome ',(0,o.jsx)(n.em,{children:"il primo"})," elemento inserito sar\xe0 il ",(0,o.jsx)(n.em,{children:"primo"})," ad essere rimosso; \xe8 il fratello della ",(0,o.jsx)(n.a,{href:"/montrecode/pila",children:"pila"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"operazioni",children:"Operazioni"}),"\n",(0,o.jsx)(n.p,{children:"Queste le operazioni che si possono effettuare su una pila:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Restituisce true se la coda \xe8 vuota\nboolean isEmpty()\n// Inserisce v in fondo alla coda\nenqueue(Item v)\n// Estrae l\u2019elemento in testa alla coda e lo restituisce al chiamante\nItem dequeue()\n// Legge l\u2019elemento in testa alla coda\nItem top()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"possibile-implementazione",children:"Possibile implementazione"}),"\n",(0,o.jsx)(n.p,{children:"Mostriamo una possibile implementazione di una coda basata sui vettori circolari:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"Item[ ] A // Elementi\nint n // Dim. attuale\nint testa // Testa\nint m // Dim. massima\nQueue Queue(int dim)\n    Queue t = new Queue\n    t.A = new int[0 . . . dim \u2212 1]\n    t.m = dim\n    t.testa = 0\n    t.n = 0\n    return t\n\nItem top()\n    precondition: n > 0\n    return A[testa]\n\nboolean isEmpty()\n    return n = 0\n\nItem dequeue()\n    precondition: n > 0\n    Item t = A[testa]\n    testa = (testa + 1) mod m\n    n = n \u2212 1\n    return t\nenqueue(Item v)\n    precondition: n < m\n    A[(testa + n) mod m] = v\n    n = n + 1\n"})})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);